#summary Guide to using xUmlCompiler

==Introduction==
This guide shows you how to define, view, generate and execute a system using xUmlCompiler.

==Setup==
Checkout the latest version and run the build.xml file with ant (works fine with 1.7). This creates the xuml-compiler.jar and dowloads its dependencies from Maven repositories.

Include the jars below in your classpath:
  * xUmlCompiler/temp/deployment/xuml-compiler.jar
  * xUmlCompiler/temp/dependencies/*.jar

==Define a system==
Consider this class diagram:

_Figure 1:_

http://xuml-compiler.googlecode.com/svn/trunk/xUmlCompiler/docs/wiki/class1.png

To define this system create the class [http://xuml-compiler.googlecode.com/svn/trunk/xUmlCompiler/src/java/moten/david/uml/xuml/model/example/shop/Shop.java Shop.java]

{{{
package moten.david.uml.xuml.model.example.shop;

import java.io.IOException;

import model.AssociationClass;
import model.Class;
import model.Primitive;
import moten.david.uml.xuml.model.Multiplicity;
import moten.david.uml.xuml.model.util.SystemBase;

public class Shop extends SystemBase {

	private static final String schema = "SHOP";
	private static final String systemName = "Shop";

	public Shop() {
		super(schema, systemName);
		initialize();
	}

	private void initialize() {
		model.Package pkg = createRootPackage("shop", "shop system");
		Class customer = createClassWithArbitraryId(pkg, "Customer",
				"a shop customer, a potential or actual purchaser of products from the shop");
		createAttribute(customer, "name");
		createAttribute(customer, "billingName");
		createAttribute(customer, "billingAddress");
		createAttribute(customer, "shippingName");
		createAttribute(customer, "shippingAddress");

		Class order = createClassWithArbitraryId(pkg, "Order",
				"an order of products made by a customer");
		createAttribute(order, "timeCreated", Primitive.TIMESTAMP);

		Class product = createClassWithArbitraryId(pkg, "Product", "products");
		createAttribute(product, "numberInStock", Primitive.INTEGER);
		createAttribute(product, "numberCommitted", Primitive.INTEGER);

		AssociationClass orderProduct = createAssociationClassWithArbitraryId(
				pkg, "OrderProduct", "products on an order");
		createAttribute(orderProduct, "itemCount", Primitive.INTEGER);

		Class shipment = createClassWithArbitraryId(pkg, "Shipment",
				"shipment of an order");
		createAttribute(shipment, "timePacked", Primitive.TIMESTAMP);
		createAttribute(shipment, "timeSent", Primitive.TIMESTAMP);
		createAttribute(shipment, "timeUnpacked", Primitive.TIMESTAMP);
		createAttribute(shipment, "comment");

		createAssociation("R1", createAssociationEndPrimary(customer,
				Multiplicity.ONE, "is made by"), createAssociationEndSecondary(
				order, Multiplicity.MANY, "makes"));
		createAssociation("R2", createAssociationEndPrimary(order,
				Multiplicity.ONE, "delivers"), createAssociationEndSecondary(
				shipment, Multiplicity.ZERO_ONE, "is delivered by"));

		createAssociation(
				"R3",
				createAssociationEndPrimary(order, Multiplicity.MANY,
						"is included in"),
				createAssociationEndSecondary(product, Multiplicity.MANY,
						"includes")).setAssociationClass(orderProduct);

	}

	public static void main(String[] args) throws NumberFormatException,
			IOException {
		Shop shop = new Shop();
		shop.view("src/viewer/Shop.ini");
	}  

}

}}}
==View the system==
Before you run the viewer you need to indicate where you are going to save the setttings for the view of the Shop system. The file is currently set to be _src/viewer/Shop.ini_. Change it if you like.

To view the system, run the above class (the main method calls the viewer). You will need to reposition the elements but when you close the viewer the positions will be saved automatically.
 
You may want to change the name of the location of the settings file in the main method.

When you run the viewer you will see a window with the image of Figure 1.

==Add the State Machine==
Now we add in the state machine details to the Shop class:

{{{
	private void initialize() {
		...
		createOrderStateMachine(order);
		createShipmentStateMachine(shipment);
	}

		public void createOrderStateMachine(Class order) {
		State open = createState(order, "Open");
		State delivered = createState(order, "Delivered");
		State cancelled = createState(order, "Cancelled");
		State beingPreparedAndShipped = createState(order,
				"Being Prepared and Shipped");
		CallEvent createOrder = createCallEvent(order, "createOrder");
		SignalEvent addProduct = createSignalEvent(order, "addProduct");
		createParameter(addProduct, "product", "Product");
		SignalEvent removeProduct = createSignalEvent(order, "removeProduct");
		createParameter(addProduct, "product", "Product");
		SignalEvent changeQuantity = createSignalEvent(order,
				"changeProductQuantity");
		createParameter(addProduct, "product", "Product");
		createParameter(addProduct, "newQuantity", Primitive.INTEGER);
		SignalEvent ship = createSignalEvent(order, "ship");
		SignalEvent cancel = createSignalEvent(order, "cancel");
		createParameter(addProduct, "newQuantity", Primitive.INTEGER);

		createTransition(order.getStateMachine().getInitialState(), open,
				createOrder);
		createTransition(open, open, addProduct);
		createTransition(open, open, changeQuantity);
		createTransition(open, open, removeProduct);
		createTransition(open, cancelled, cancel);
		createTransition(beingPreparedAndShipped, cancelled, cancel);
		createTransition(open, beingPreparedAndShipped, ship);
		createTransition(beingPreparedAndShipped, cancelled, cancel);
	}

	private void createShipmentStateMachine(Class shipment) {
		State beingPrepared = createState(shipment, "Being Prepared");
		State beingShipped = createState(shipment, "Being Shipped");
		State shippedState = createState(shipment, "Shipped");
		State cancelled = createState(shipment, "Cancelled");
		State deliveredState = createState(shipment, "Delivered");
		State lostState = createState(shipment, "Lost");
		State returnedState = createState(shipment, "Returned");
		CallEvent ship = createCallEvent(shipment, "createShipment");
		createParameter(ship, "order", "Order");
		SignalEvent prepared = createSignalEvent(shipment, "prepared");
		createParameter(ship, "time", Primitive.TIMESTAMP);
		SignalEvent shipped = createSignalEvent(shipment, "shipped");
		createParameter(shipped, "time", Primitive.TIMESTAMP);
		SignalEvent delivered = createSignalEvent(shipment, "delivered");
		createParameter(delivered, "time", Primitive.TIMESTAMP);
		SignalEvent cancel = createSignalEvent(shipment, "cancel");
		createParameter(cancel, "time", Primitive.TIMESTAMP);
		SignalEvent lost = createSignalEvent(shipment, "lost");
		createParameter(cancel, "time", Primitive.TIMESTAMP);
		createParameter(cancel, "comment");
		SignalEvent returned = createSignalEvent(shipment, "returned");
		createParameter(cancel, "time", Primitive.TIMESTAMP);
		createParameter(cancel, "comment");

		createTransition(shipment.getStateMachine().getInitialState(),
				beingPrepared, ship);
		createTransition(beingPrepared, beingShipped, prepared);
		createTransition(beingShipped, shippedState, shipped);
		createTransition(beingPrepared, cancelled, cancel);
		createTransition(beingShipped, cancelled, cancel);
		createTransition(shippedState, deliveredState, delivered);
		createTransition(shippedState, lostState, lost);
		createTransition(shippedState, returnedState, returned);
	}
}}}

Running the viewer now gives us:

_Figure 2:_

http://xuml-compiler.googlecode.com/svn/trunk/xUmlCompiler/docs/wiki/class2.png


==Add methods to the classes==
Add this code to the end of the initialize() method: 

{{{
    createOperation(order, "dispatch", "dispatches the order", null, false);
    createOperation(
        customer,
        "getCreditRating",
        "gets the credit rating",
        "Integer", false);
}}}

Run the viewer and we see the new operations in the classes.

http://xuml-compiler.googlecode.com/svn/trunk/xUmlCompiler/docs/guide/images/img03.jpg

==Generate the classes==
xUmlCompiler generates
  * entity classes with ejb3 annotations (and possible hibernate specific annotations)
  * interfaces for all entities
  * object factory classes
  * injector classes for late binding of actions
  * search classes based on identifier and index specifications 
  * value enumerations for static constants associated with attributes

Paste in the following class:
{{{
package moten.david.uml.xuml.model.example.shop;

public class ShopGenerator {

    public static void main(String[] args) throws Exception {
        Shop shop = new Shop();
        shop.generate("temp/shop");
    }
}
}}}
All classes will be written to the directory temp/shop. Change it if you wish. Create the directory if it does not exist.

Run the main method in the above class and classes will be generated as below:

_Figure 3:_

http://xuml-compiler.googlecode.com/svn/trunk/xUmlCompiler/docs/wiki/generated1.png

Now have a look at the interface Order.java and the ejb implementation OrderImpl:

*Order.java:*
{{{
package shop;

import java.util.Date;
import shop.Shipment;
import shop.impl.ShipmentImpl;
import shop.Order;
import shop.impl.OrderImpl;
import shop.OrderProduct;
import shop.impl.OrderProductImpl;
import shop.Customer;
import shop.impl.CustomerImpl;

import java.util.Set;
import java.util.List;
import javax.persistence.EntityManager;


/**
* an order of products made by a customer
*
* @generated
* @generatedBy xUML
*/

public interface Order  {

	/**
	 * getter for id
	 */
    public int getId();

	/**
	 * setter for id
	 */
	public void setId(int id);

	/**
	 * getter for timeCreated
	 */
    public Date getTimeCreated();

	/**
	 * setter for timeCreated
	 */
	public void setTimeCreated(Date timeCreated);

	/**
	* via association "R2"
	**/
	public Shipment getShipment();

	/**
	* via association "R2"
	**/
	public void setShipment(Shipment shipment);

	/**
	* via association "R3A"
	**/
	public Set<OrderProduct> getOrderProduct();

	/**
	* via association "R3A"
	**/
	public void setOrderProduct(Set<OrderProduct> orderProduct);

	/**
	* via association "R1"
	**/
	public Customer getCustomer();

	/**
	* via association "R1"
	**/
	public void setCustomer(Customer customer);
	
	/**
	* process the received Call event <em>createOrder</em>
	*/
	public void processEvent(final EventCreateOrder event);
	
	/**
	* process the received Signal event <em>addProduct</em>
	*/
	public void processEvent(final EventAddProduct event);
	
	/**
	* process the received Signal event <em>removeProduct</em>
	*/
	public void processEvent(final EventRemoveProduct event);
	
	/**
	* process the received Signal event <em>changeProductQuantity</em>
	*/
	public void processEvent(final EventChangeProductQuantity event);
	
	/**
	* process the received Signal event <em>ship</em>
	*/
	public void processEvent(final EventShip event);
	
	/**
	* process the received Signal event <em>cancel</em>
	*/
	public void processEvent(final EventCancel event);

	/** 
	* Event <em>createOrder</em>
	* 
	*/
	public static class EventCreateOrder {
	}

	/** 
	* Event <em>addProduct</em>
	* 
	*/
	public static class EventAddProduct {
	
		/**
		* * 
		*/
		private Product product;
	
		/**
		* * 
		*/
		public Product getProduct(){
			return product;
		}
		
		public void setProduct(Product product){
			this.product = product;
		}
	}

	/** 
	* Event <em>removeProduct</em>
	* 
	*/
	public static class EventRemoveProduct {
	
		/**
		* * 
		*/
		private Product product;
	
		/**
		* * 
		*/
		public Product getProduct(){
			return product;
		}
		
		public void setProduct(Product product){
			this.product = product;
		}
	}

	/** 
	* Event <em>changeProductQuantity</em>
	* 
	*/
	public static class EventChangeProductQuantity {
	
		/**
		* * 
		*/
		private Product product;
	
		/**
		* * 
		*/
		private Integer newQuantity;
	
		/**
		* * 
		*/
		public Product getProduct(){
			return product;
		}
		
		public void setProduct(Product product){
			this.product = product;
		}
	
		/**
		* * 
		*/
		public Integer getNewQuantity(){
			return newQuantity;
		}
		
		public void setNewQuantity(Integer newQuantity){
			this.newQuantity = newQuantity;
		}
	}

	/** 
	* Event <em>ship</em>
	* 
	*/
	public static class EventShip {
	}

	/** 
	* Event <em>cancel</em>
	* 
	*/
	public static class EventCancel {
	}

	/** 
	* static class to contain static search methods 
	*/
	public static class Search {

		/**
		* returns all instances of Order
		*/
		@SuppressWarnings("unchecked")
		public static List<Order> findAll(EntityManager em) {
			return (List<Order>) em.createQuery("from Order").getResultList();
		}
		
		/**
		* returns all instances of Order satisfying the clause. Note that you might use a where clause and/or an order by clause.
		*/
		@SuppressWarnings("unchecked")
		public static List<Order> findAll(EntityManager em, String clause) {
			return (List<Order>) em.createQuery("from Order "+clause).getResultList();
		}
	}
}
}}}

*OrderImpl.java*
{{{
package shop.impl;

import java.util.Date;
import shop.Shipment;
import shop.impl.ShipmentImpl;
import shop.Order;
import shop.impl.OrderImpl;
import shop.OrderProduct;
import shop.impl.OrderProductImpl;
import shop.Customer;
import shop.impl.CustomerImpl;
import javax.persistence.*;
import org.hibernate.annotations.Type;
import org.apache.log4j.Logger;
import java.util.Set;
import java.util.HashSet;
import moten.david.uml.xuml.model.compiler.runtime.InvalidRecordException;
import com.google.inject.Inject;
import shop.*;
import shop.actions.*;
/**
* an order of products made by a customer
*
* @generated
* @generatedBy xUML
*/
@Entity(name="Order")
@Table(name="order_table", schema="SHOP")
public class OrderImpl implements Order {

	/**
	* static logger
	**/
	private static Logger log = Logger.getLogger(OrderImpl.class);

	/**
	* constructor has default access to ensure that instantiation 
	* occurs via the factory.
	*/
	protected OrderImpl(){
		//
	}
	private enum State {INITIAL_STATE, OPEN, DELIVERED, CANCELLED, BEING_PREPARED_AND_SHIPPED, FINAL_STATE};
	
	private State state = State.INITIAL_STATE;

	/**
	* member field for id
	*/
	private int id ;

	/**
	* member field for timeCreated
	*/
	private Date timeCreated ;

	/**
	* role for association "R2" (inverse role is order)
	*/
	private Shipment shipment;

	/**
	* role for association "R3A" (inverse role is order)
	*/
	private Set<OrderProduct> orderProduct = new HashSet<OrderProduct>();

	/**
	* role for association "R1" (inverse role is order)
	*/
	private Customer customer;

	/**
	*	implementation of the operations interface for this class
	*
	*/
	private OrderActions orderActions;

	/**
	* getter for the implementation of the operations interface for this class
	*
	*/
	@Transient
	public OrderActions getOrderActions() {
		return orderActions;
	}

	/**
	* setter for the implementation of the operations interface for this class.
	* This field is set via <b>guice</b> injection.
	*
	*/
	@Inject
	public void setOrderActions(OrderActions orderActions) {
		this.orderActions=orderActions;
		this.orderActions.setOrder(this);
	}

	/**
	* on load of this object from persistence necessary operations are injected.
	* This ensures that the object operations are available before the object is "used in anger".
	*/
	@PostLoad
	public void inject() {
		ObjectFactory.instance.injectMembers(this);
	}
	
	/** 
	* check that operations have been injected
	*/
	private void checkActions(){
		if (orderActions==null)
			throw new Error(
				"no implementation for operations has been injected yet! Perhaps there is no binding for OrderActions.class in the InjectorModule.");
	}

	/**
	 * getter for id
	 */
	@Id
	@Column(name="order_id", nullable=false, unique=false)
	@GeneratedValue
	public int getId(){
		return id;
	}

	/**
	 * setter for id
	 */
	public void setId(int id){
		this.id = id;
	}

	/**
	 * getter for timeCreated
	 */
	@Column(name="time_created", nullable=false, unique=false)
    @Temporal(TemporalType.TIMESTAMP)
	public Date getTimeCreated(){
		return timeCreated;
	}

	/**
	 * setter for timeCreated
	 */
	public void setTimeCreated(Date timeCreated){
		this.timeCreated = timeCreated;
	}

	/**
	* 1 to 0..1 (association "R2")
	*/
	@OneToOne(
		mappedBy = "order",
		fetch=FetchType.LAZY,
		targetEntity=ShipmentImpl.class)
	public Shipment getShipment(){
		return shipment;
	}

	public void setShipment(Shipment shipment){
		this.shipment=shipment;
	}

  	/**
  	* 1 .. * (association "R3A")
  	*/
	@OneToMany(
		mappedBy = "order",
		cascade=CascadeType.ALL,
		fetch=FetchType.LAZY,
		targetEntity=OrderProductImpl.class)
	public Set<OrderProduct> getOrderProduct(){
		return orderProduct;
	}

	public void setOrderProduct(Set<OrderProduct> orderProduct){
		this.orderProduct=orderProduct;
	}

  	/**
  	* * to 1 (association "R1")
  	*/
	@ManyToOne(targetEntity=CustomerImpl.class)
	@JoinColumn(name = "customer_id",nullable = false)
	public Customer getCustomer(){
		return customer;
	}

	public void setCustomer(Customer customer){
		this.customer=customer;
	}
 
 	@Column(name="state")
	public String getStateValue() {
		return getState().toString();
	}
	
	public void setStateValue(String stateString) {
		setState(State.valueOf(stateString));
	}
	
	@Transient
	public State getState() {
		return state;
	}
	
	public void setState(State state) {
		this.state = state;
	}
	
	/**
	* process the received Call event <em>createOrder</em>
	*/
	public void processEvent(final Order.EventCreateOrder event) {
		log.debug("processing event createOrder");
		
		if (state.equals(State.INITIAL_STATE)){
			state = State.OPEN;
			checkActions();
			synchronized (this) {
				log.debug("performOnEntryOpen");
				orderActions.performOnEntryOpen(event);
			}
		}
	}
	
	/**
	* process the received Signal event <em>addProduct</em>
	*/
	public void processEvent(final Order.EventAddProduct event) {
		log.debug("processing event addProduct");
		
		if (state.equals(State.OPEN)){
			state = State.OPEN;
			final Object thisObject = this;
			Thread t = new Thread(new Runnable() {
					public void run() {
						checkActions();
						synchronized (thisObject) {
							log.debug("performOnEntryOpen");
							orderActions.performOnEntryOpen(event);
						}
					}
				});
			t.start();
		}
	}
	
	/**
	* process the received Signal event <em>removeProduct</em>
	*/
	public void processEvent(final Order.EventRemoveProduct event) {
		log.debug("processing event removeProduct");
		
		if (state.equals(State.OPEN)){
			state = State.OPEN;
			final Object thisObject = this;
			Thread t = new Thread(new Runnable() {
					public void run() {
						checkActions();
						synchronized (thisObject) {
							log.debug("performOnEntryOpen");
							orderActions.performOnEntryOpen(event);
						}
					}
				});
			t.start();
		}
	}
	
	/**
	* process the received Signal event <em>changeProductQuantity</em>
	*/
	public void processEvent(final Order.EventChangeProductQuantity event) {
		log.debug("processing event changeProductQuantity");
		
		if (state.equals(State.OPEN)){
			state = State.OPEN;
			final Object thisObject = this;
			Thread t = new Thread(new Runnable() {
					public void run() {
						checkActions();
						synchronized (thisObject) {
							log.debug("performOnEntryOpen");
							orderActions.performOnEntryOpen(event);
						}
					}
				});
			t.start();
		}
	}
	
	/**
	* process the received Signal event <em>ship</em>
	*/
	public void processEvent(final Order.EventShip event) {
		log.debug("processing event ship");
		
		if (state.equals(State.OPEN)){
			state = State.BEING_PREPARED_AND_SHIPPED;
			final Object thisObject = this;
			Thread t = new Thread(new Runnable() {
					public void run() {
						checkActions();
						synchronized (thisObject) {
							log.debug("performOnEntryBeingPreparedAndShipped");
							orderActions.performOnEntryBeingPreparedAndShipped(event);
						}
					}
				});
			t.start();
		}
	}
	
	/**
	* process the received Signal event <em>cancel</em>
	*/
	public void processEvent(final Order.EventCancel event) {
		log.debug("processing event cancel");
		
		if (state.equals(State.OPEN)){
			state = State.CANCELLED;
			final Object thisObject = this;
			Thread t = new Thread(new Runnable() {
					public void run() {
						checkActions();
						synchronized (thisObject) {
							log.debug("performOnEntryCancelled");
							orderActions.performOnEntryCancelled(event);
						}
					}
				});
			t.start();
		}
		else
		if (state.equals(State.BEING_PREPARED_AND_SHIPPED)){
			state = State.CANCELLED;
			final Object thisObject = this;
			Thread t = new Thread(new Runnable() {
					public void run() {
						checkActions();
						synchronized (thisObject) {
							log.debug("performOnEntryCancelled");
							orderActions.performOnEntryCancelled(event);
						}
					}
				});
			t.start();
		}
	}
}
}}}

Notice the getter and setter methods on the Customer interface class and the search methods. If we had defined identifiers (uniqueness rules other than the primary key id field) we would see finders for the identifier attribute groups as well.  

http://xuml-compiler.googlecode.com/svn/trunk/xUmlCompiler/docs/guide/images/img05.jpg

==Implement actions==
All methods and state machine entry points should be implemented by your behaviour classes.

Here's the behaviour class for the Order class:
{{{
package moten.david.uml.xuml.model.example.shop;

import shop.Order;
import shop.actions.OrderActions;

public class OrderBehaviour implements OrderActions {

    private Order order;

    @Override
    public void dispatch() {
        System.out.println("dispatching order " + order.getId());
    }

    @Override
    public void setOrder(Order order) {
        this.order = order;
    }

}
}}}
==Define an injector==
{{{
package moten.david.uml.xuml.model.example.shop;

import shop.actions.OrderActions;

import com.google.inject.AbstractModule;

public class ShopInjectorModule extends AbstractModule {

     @Override
     protected void configure() {
          bind(OrderActions.class).to(OrderBehaviour.class);
     }

}
}}}
==Execute the system==
To execute the system we must first ensure that the generated objects use the shop InjectorModule for late bound injection of behaviour:
{{{
package moten.david.uml.xuml.model.example.shop;

import shop.ObjectInjector;

import com.google.inject.Guice;

public class ShopLauncher {

    public static void main(String[] args) {
        // enable injection of actions
        ObjectInjector.setInjector(Guice
                .createInjector(new ShopInjectorModule()));
    }

}
}}}