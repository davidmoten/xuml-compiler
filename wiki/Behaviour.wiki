#Guice injected behaviour

Java is used as the action language in xuml-compiler. Using Guice we define bindings from the generated behaviour interface classes to our implementations.

== How do I get an `EntityManager` in my behaviour class? ==
Simple behaviour classes may not need an entity manager at all (e.g. an event that sets an address of a person for example). However, more complex business logic such as performing a find in a behaviour class might need access to the current `EntityManager`. 

A useful pattern is to use `ThreadLocal` (thread specific object storage) to provide thread specific `EntityManagers`:
{{{
If the current thread already has an open entity manager then reuse that one otherwise create one with the EntityManagerFactory.
}}}
In your injector module use [http://code.google.com/p/xuml-compiler/source/browse/trunk/xuml-compiler/src/main/java/moten/david/util/persistence/ThreadLocalEntityManagerFactory.java ThreadLocalEntityManagerProvider]: 
{{{
  bind(EntityManagerFactory.class).toProvider(ThreadLocalEntityManagerProvider.class);
}}}

== Events ==
On first look Executable UML appears to constrain state models to one event per destination state. This is not true because Executable UML supports the idea of Polymorphic Events in that any subclass of an event may be used to transition to a state.  

xUmlCompiler does not support polymorphic events, a simpler approach was taken in that each state can be transited to by multiple events. Reuse scenarios in the behaviour class can be handled in the normal way in java code (common methods). 

Another benefit of the xuml-compiler event approach is that if a single on entry method was used for a state then polymorphic events would necessitate multiple if-else statements checking for different event subclasses within that method. There is no guarantee that all subclasses would be covered. Using the xuml-compiler approach the behaviour class contains methods for all possible events and it's obvious to the developer if a method hasn't been coded.